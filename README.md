YAL - Yet Another Language
==========================

A toy language implementation to delve into the topic of compilers and virtual machines.

YAL is a language that is statically typed with auto inference. It takes some clues from languagues such as Google's GO, Python, C, Swift/Objective-C and Lua.

The project starts out with an VM that can be easily embedded in other programs. Further down the line, when all the language features have been implemented, I intend to use LLVM to generate native binaries as well as provide easy to use native code interfaces as well as VM functions.

To support this idea, the virtual machine is written in C99 to allow easy embedding in any sort
of application and the compiler is written in C++.

At the moment, the feature set of the language is limited to basic types (bool, int32, uint32, int64, uint64, float32 and float64) ,functions with one return value and conditional statements. See the test files for examples.

Since this is still at early development stages, the language itself is subject to continuous change.

Building
--------

YAL depends on:
* Bison >= 3.0
* Flex >= 2.5.0
* GTest (automatically downloaded by CMake)

YAL has been build and tested on:
* GNU/Linux x86_64 (Fedora 21-23)
* Mac OS X 10.10, 10.11 x86_64

The project can be built using the standard CMake build process.
```
cmake -DCMAKE_BUILD_TYPE=Release <source directory>
make 
make install
```
Usage
-----

YAL comes with three componentes:

* yalc - Compiler which generates binary code. Supports input through stdin or files. 
* yaldisass - Disassembler for the binary code generated by yalc.
* yale - Simple implementation of the YALVM which can execute the generated code. At the end of the execution, it will print the values of all the global variables present in the code.

#Example
##Input file
```
$cat test.yal
var global= "hello"

func test()
var str1 = " ZZZZ "

if ( true )
str1 = "XXX"
var str2 = "YYY"
var str3 = str2
global = str2
end
end

print (global)
test()
print (global)
```

## Compiler Call
This will generate an output file called a.out.yalb, which an be changed with the -o
option.
```
$ yalc --dump-ast test.yal
Module
|-VariableDeclNode<ln 4:5  cl 19:0> 'global'
| `-ObjectCreateNode 
|   `-StringCreateNode<ln 4:4  cl 12:19> 
|     `-ConstantNode<ln 4:4  cl 12:19> type:ConstantTypeText
|-FunctionDeclNode<ln 15:15  cl 0:3> 'test' : 'void'
| |-ArgumentDeclsNode<ln 6:6  cl 10:11> 
| `-CodeBodyNode<ln 7:8  cl 21:0> 
|   |-VariableDeclNode<ln 7:8  cl 21:0> 'str1'
|   | `-ObjectCreateNode 
|   |   `-StringCreateNode<ln 7:7  cl 13:21> 
|   |     `-ConstantNode<ln 7:7  cl 13:21> type:ConstantTypeText
|   `-ConditionNode<ln 14:14  cl 2:5> 
|     |-ConstantNode<ln 9:9  cl 7:11> type:ConstantTypeBool
|     `-CodeBodyNode<ln 10:11  cl 16:0> 
|       |-AssignOperatorNode<ln 10:11  cl 16:0> '= '
|       | |-VariableAccessNode<ln 10:10  cl 9:10> 'str1'
|       | `-ObjectCreateNode 
|       |   `-StringCreateNode<ln 10:10  cl 11:16> 
|       |     `-ConstantNode<ln 10:10  cl 11:16> type:ConstantTypeText
|       |-VariableDeclNode<ln 11:12  cl 20:0> 'str2'
|       | `-ObjectCreateNode 
|       |   `-StringCreateNode<ln 11:11  cl 15:20> 
|       |     `-ConstantNode<ln 11:11  cl 15:20> type:ConstantTypeText
|       |-VariableDeclNode<ln 12:13  cl 19:0> 'str3'
|       | `-VariableAccessNode<ln 12:13  cl 19:0> 'str2'
|       `-AssignOperatorNode<ln 13:14  cl 17:0> '= '
|         |-VariableAccessNode<ln 13:13  cl 11:12> 'global'
|         `-VariableAccessNode<ln 13:14  cl 17:0> 'str2'
|-PrintNode<ln 17:17  cl 13:14> 
| `-PrintArgsNode<ln 17:17  cl 13:14> 
|   `-VariableAccessNode<ln 17:17  cl 13:14> 'global'
|-FunctionCallNode<ln 18:18  cl 5:6> 'test'
| `-FunctionCallArgsNode<ln 18:18  cl 5:6> 
`-PrintNode<ln 19:19  cl 13:14> 
  `-PrintArgsNode<ln 19:19  cl 13:14> 
   `-VariableAccessNode<ln 19:19  cl 13:14> 'global'
```

## Dissasembler Call
```
# Constants 32: 0
# Constants 64: 0
# Globals   32: 0
# Globals   64: 0
# functions   : 2
# strings     : 4
# string size : 37

> String 0: "XXX"
> String 1: "YYY"
> String 2: " ZZZZ "
> String 3: "hello"

> Global Init Code
[0000] 00000203  load globalptr: r002, 0
[0001] 00030176       str alloc: r001, 3
[0002] 00010267        copy reg: r002, r001
[0003] 00000206 store globalptr: r002, 0
[0004] 00000000            halt: 


> Global Dtor Code
[0000] 00000003  load globalptr: r000, 0
[0001] 00010074     obj release: r000, 1
[0002] 00000077     str dealloc: r000
[0003] 00000000            halt: 


> Function 0: test
>   Arguments: 0
>   Registers: 5
>   Native   : No
[0000] 00020276       str alloc: r002, 2
[0001] 00020067        copy reg: r000, r002
[0002] 00010209        load val: r002, 1
[0003] 00120261      jump false: r002, 18
[0004] 00000476       str alloc: r004, 0
[0005] 00010074     obj release: r000, 1
[0006] 00000077     str dealloc: r000
[0007] 00040067        copy reg: r000, r004
[0008] 00010376       str alloc: r003, 1
[0009] 00030167        copy reg: r001, r003
[0010] 00000173     obj acquire: r001
[0011] 00010267        copy reg: r002, r001
[0012] 00000303  load globalptr: r003, 0
[0013] 00010374     obj release: r003, 1
[0014] 00000377     str dealloc: r003
[0015] 00000173     obj acquire: r001
[0016] 00010367        copy reg: r003, r001
[0017] 00000306 store globalptr: r003, 0
[0018] 00010274     obj release: r002, 1
[0019] 00000277     str dealloc: r002
[0020] 00010174     obj release: r001, 1
[0021] 00000177     str dealloc: r001
[0022] 00010074     obj release: r000, 1
[0023] 00000077     str dealloc: r000
[0024] 0000ff66          return: r255

> Function 1: globalfunction
>   Arguments: 0
>   Registers: 3
>   Native   : No
[0000] 00000003  load globalptr: r000, 0
[0001] 00000070     printstrobj: r000
[0002] 00000071         printnl: 
[0003] 00000262       laod func: r002, 0
[0004] 00ff0264            call: r002, r255
[0005] 00000003  load globalptr: r000, 0
[0006] 00000070     printstrobj: r000
[0007] 00000071         printnl: 
[0008] 00000000            halt: 

```

## Execution call

```
$ yale a.out.yalb
hello
YYY

```

Future version of the executor will support output to stdout and this approach will be optional.

Future work
-----------
Future versions of the project aim to support the following:

* [X] ~~Comment support~~
* [ ] Compiler Optimisations
  * [X] ~~Global Variables~~
  * [ ] Dead Code removal
  * [X] Register copy reduction (WIP)
* [ ] Language Documentation
* [ ] Remove dependency on Flex/Bison
* [X] ~~Better error messages in the compiler~~
* [ ] Loops
  * [X] ~~While loops~~
  * [ ] For loops
* [X] ~~Printing support~~
* [X] Memory management
  * [X] ~~Automatic Reference Counting (ARC) a la Objective-C~~
  * [ ] Handle cyclic references using weak attribute
* [ ] Custom data types
* [ ] Interfaces
  * Inspired by Google GO
* [X] Native Code Interface 
  * [ ] Compiler support to generate all the boilerplate code or utility functions
* [X] ~~VM Function Handler~~
* [ ] Builtin objects
  * [X] ~~Strings~~
  * [ ] Arrays 
  * [ ] HashMaps
* [ ] Module linking
* [ ] C++ Wrapper around yalvm C code.
* [ ] Multiple return values?
* [ ] LLVM bytecode generation
