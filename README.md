YAL - Yet Another Language
==========================

A toy language implementation to delve into the topic of compilers and virtual machines.

YAL is a language that is statically typed with auto inference. It takes some clues from languagues such as Google's GO, Python, C, Swift/Objective-C and Lua.

The project starts out with an VM that can be easily embedded in other programs. Further down the line, when all the language features have been implemented, I intend to use LLVM to generate native binaries as well as provide easy to use native code interfaces as well as VM functions.

To support this idea, the virtual machine is written in C99 to allow easy embedding in any sort
of application and the compiler is written in C++.

At the moment, the feature set of the language is limited to basic types (bool, int32, uint32, int64, uint64, float32 and float64) ,functions with one return value and conditional statements. See the test files for examples.

Since this is still at early development stages, the language itself is subject to continuous change.

Building
--------

YAL depends on:
* Bison >= 3.0
* Flex >= 2.5.0
* GTest (automatically downloaded by CMake)

YAL has been build and tested on:
* GNU/Linux x86_64 (Fedora 21/22)
* Mac OS X 10.10 x86_64

The project can be built using the standard CMake build process.
```
cmake -DCMAKE_BUILD_TYPE=Release <source directory>
make 
make install
```
Usage
-----

YAL comes with three componentes:

* yalc - Compiler which generates binary code. Supports input through stdin or files. 
* yaldisass - Disassembler for the binary code generated by yalc.
* yale - Simple implementation of the YALVM which can execute the generated code. At the end of the execution, it will print the values of all the global variables present in the code.
* yalhash - Utility to print the hashes of global variables dumped by yale.

#Example
##Input file
```
var a = 20

func test()
   a = a + 1
end

test()
```

## Compiler Call
This will generate an output file called a.out.yalb. Hardcoded for now, will be 
possible to change in the future.
```
$ yale [input file]
```

## Dissasembler Call
```
$ yaldisass a.out.yalb
# Constants 32: 0
# Constants 64: 0
# Globals   32: 1
# Globals   64: 0
# functions   : 1

> Function 0:3f75ccc1
>   Arguments: 0
>   Registers: 5
[0000] 00000201   load global32: r002, 0
[0001] 00010407        load val: r004, 1
[0002] 0402010A            addi: r001, r002, r004
[0003] 00010060        copy reg: r000, r001
[0004] 00000003  store global32: r000, 0
[0005] 0000FF5F          return: r255
> Function 1:301aabe1
>   Arguments: 0
>   Registers: 1
[0000] 00140007        load val: r000, 20
[0001] 00000003  store global32: r000, 0
[0002] 0000005C       laod func: r000, 0
[0003] 00FF005E            call: r000, r255
[0004] 00000000            halt:

```

## Execution call
If there is a global variable present in the code, the executor will print the 
value in all possible formats at the end. Variables are identified by the hash
of the variable name. Use yalhash to get the hash for the variable name.

```
$ yale a.out.yalb
Globals 32
> 10e5af18
  hex32: 15
  hex64: 7FFF00000015
  i32  : 21
  i64  : 140733193388053
  u32  : 21
  u64  : 140733193388053
  f32  : 0.000000
  f64  : 0.000000
```

Future version of the executor will support output to stdout and this approach will be optional.

Future work
-----------
Future versions of the project aim to support the following:

  * Comment support
  * Compiler Optimisations
  * Language Documentation
  * Remove dependency on Flex/Bison
  * Better error messages in the compiler.
  * Loops
  * Printing to stdout support
  * Memory management
    * Automatic Reference Counting (ARC) a la Objective-C
  * Custom data types
  * Interfaces
    * Inspired by Google GO
  * Native Code Interface
    * Compiler support to generate all the boilerplate code or utility functions
  * VM Function Handler
  * Builtin objects
    * Strings
    * Arrays 
    * HashMaps
  * Module linking
  * C++ Wrapper around yalvm C code.
  * Multiple return values?
  * LLVM bytecode generation
    * JIT on Native execution
