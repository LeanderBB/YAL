/*
 *  Copyright 2017 by Leander Beernaert (leanderbb@gmail.com)
 *
 *  This file is part of YAL.
 *
 *  YAL is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3
 *  of the License, or (at your option) any later version.
 *
 *  YAL is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with YAL. If not, see <http://www.gnu.org/licenses/>.
 */
%name YALParser

%token_prefix YAL_TOKEN_

%include {
#include <cassert>
#include <vector>
#include "yal/parser/parser.h"
#include "yal/util/log.h"
#include "yal/util/stringref.h"
#include "yal/ast/typebuiltin.h"
#include "yal/ast/declfunction.h"
#include "yal/ast/decltypefunction.h"
#include "yal/ast/declmodule.h"
#include "yal/ast/reftypebuiltin.h"
#include "yal/ast/reftypeidentifier.h"
#include "yal/ast/declvar.h"
#include "yal/ast/declparamvar.h"
#include "yal/ast/stmtexpression.h"
#include "yal/ast/stmtreturn.h"
#include "yal/ast/exprunaryoperator.h"
#include "yal/ast/exprbinaryoperator.h"
#include "yal/ast/statement.h"
#include "yal/ast/statementlist.h"
#define YYMALLOCARGTYPE size_t
}


%extra_argument { yal::Parser *pParser }

%syntax_error {

    pParser->logParseFailure();
    {
        yal::Log::MultiLineScope multiLineScope(pParser->getLog());
        pParser->getLog().error("Expected one of the following tokens:\n");
        int n = sizeof(yyTokenName) / sizeof(yyTokenName[0]);
        for (int i = 0; i < n; ++i) {
            int a = yy_find_shift_action(yypParser, (YYCODETYPE)i);
            if (a < YYNSTATE + YYNRULE) {
                pParser->getLog().error("%\n",yyTokenName[i]);
            }
        }
    }
}

%right ASSIGN.
%left OR.
%left AND.
%left BIT_OR.
%left BIT_XOR.
%left BIT_AND.
%nonassoc EQ NE GT LT GE LE.
%left PLUS MINUS.
%left MULT DIV MOD.
%right NEG.
%right NOT.
%right DOT.

%type type_builtin {yal::RefTypeBuiltin*}
%type decl_function {yal::DeclFunction*}
%type type_function_decl {yal::DeclTypeFunction*}
%type decls {yal::DeclModule*}
%type module {yal::DeclModule*}
%type function_return_decl {yal::RefType*}
%type type_specifier {yal::RefType*}
%type named_decl {yal::StringRefPod}
%type function_args_decl {yal::DeclParamVarContainer*}
%type function_arg_decl {yal::DeclParamVar*}
%type statement_list {yal::StatementList*}
%type statement {yal::Statement*}
%start_symbol  module
%token_type {yal::StringRefPod}

module ::= decls END.

decls ::= decls type_decl.
decls(A) ::= decls(B) decl_function(C). {
        A =B; B->addDecl(C);
}
decls::= decls type_function_decl.
decls(A) ::=. {
        A =  pParser->newAstNode<yal::DeclModule>();
     }
// Type  specifiers
type_specifier(A) ::= type_builtin(B). {A=B;}
type_specifier(A) ::= type_array. {A = nullptr;}
type_specifier(A) ::= IDENTIFIER(B). {A = pParser->newAstNode<yal::RefTypeIdentifier>(B);}

type_builtin(A) ::= TYPE_BOOL. {
        A = pParser->newAstNode<yal::RefTypeBuiltin>(pParser->getModule().getTypeContext().getTypeBuiltinBool());
        }
type_builtin(A) ::= TYPE_INT8. {
        A = pParser->newAstNode<yal::RefTypeBuiltin>(pParser->getModule().getTypeContext().getTypeBuiltinI8());
        }
type_builtin(A) ::= TYPE_UINT8. {
        A  = pParser->newAstNode<yal::RefTypeBuiltin>(pParser->getModule().getTypeContext().getTypeBuiltinU8());
        }
type_builtin(A) ::= TYPE_INT16. {
        A = pParser->newAstNode<yal::RefTypeBuiltin>(pParser->getModule().getTypeContext().getTypeBuiltinI16());
        }
type_builtin(A) ::= TYPE_UINT16. {
        A  = pParser->newAstNode<yal::RefTypeBuiltin>(pParser->getModule().getTypeContext().getTypeBuiltinU16());
        }
type_builtin(A) ::= TYPE_INT32. {
        A = pParser->newAstNode<yal::RefTypeBuiltin>(pParser->getModule().getTypeContext().getTypeBuiltinI32());
        }
type_builtin(A) ::= TYPE_UINT32. {
        A = pParser->newAstNode<yal::RefTypeBuiltin>(pParser->getModule().getTypeContext().getTypeBuiltinU32());
        }
type_builtin(A) ::= TYPE_INT64. {
        A = pParser->newAstNode<yal::RefTypeBuiltin>(pParser->getModule().getTypeContext().getTypeBuiltinI64());
        }
type_builtin(A) ::= TYPE_UINT64. {
        A = pParser->newAstNode<yal::RefTypeBuiltin>(pParser->getModule().getTypeContext().getTypeBuiltinU64());
        }
type_builtin(A) ::= TYPE_FLOAT. {
        A = pParser->newAstNode<yal::RefTypeBuiltin>(pParser->getModule().getTypeContext().getTypeBuiltinFloat());
        }
type_builtin(A) ::= TYPE_DOUBLE. {
        A = pParser->newAstNode<yal::RefTypeBuiltin>(pParser->getModule().getTypeContext().getTypeBuiltinDouble());
        }

type_array ::= type_builtin ARRAY_BEGIN ARRAY_END.

// custom type declaration
type_decl ::= TYPE IDENTIFIER COLON STRUCT SCOPE_BEGIN type_var_decls SCOPE_END.
type_decl ::= TYPE IDENTIFIER COLON type_specifier SEMI_COLON.

type_var_decls ::= type_var_decls type_var_decl.
type_var_decls ::= type_var_decl.

type_var_decl ::= IDENTIFIER COLON type_specifier SEMI_COLON.

// Functions

decl_function (A) ::= FUNCTION IDENTIFIER(B) PAR_BEGIN function_args_decl(D) PAR_END
        function_return_decl(C) function_scope. {
        A = pParser->newAstNode<yal::DeclFunction>(B, D, C);
        }


type_function_decl(A)::= FUNCTION type_specifier(B) COLON COLON IDENTIFIER(C)
        PAR_BEGIN function_args_decl(E) PAR_END
        function_return_decl(D) function_scope. {
            A = pParser->newAstNode<yal::DeclTypeFunction>(C, E, B, D);
        }


function_args_decl(A) ::= function_args_decl(B) COMMA function_arg_decl(C). {
        B->addDeclParam(C);
        A = B;
}
function_args_decl(A) ::= function_arg_decl(B). {
        A = pParser->newAstNode<yal::DeclParamVarContainer>();
        A->addDeclParam(B);
}
function_args_decl(A) ::= . {
        A = nullptr;
}

function_arg_decl(A) ::= IDENTIFIER(B) COLON type_specifier(C). {
    A = pParser->newAstNode<yal::DeclParamVar>(B, C);
}

function_return_decl(A) ::= COLON type_specifier(B). { A = B;}
function_return_decl(A)::=. {A = nullptr;}

function_scope ::= SCOPE_BEGIN SCOPE_END.
function_scope ::= SCOPE_BEGIN statement_list SCOPE_END.

// Statements
statement_list(A) ::= statement_list(B) statement(C).{
    B->addStatement(C);
    A=B;
}
statement_list(A) ::= statement(B). {
    A = pParser->newAstNode<yal::StatementList>();
    A->addStatement(B);
}


statement(A) ::= var_assignment SEMI_COLON. {
   A = nullptr;
}
statement(A)::= var_decl SEMI_COLON. {
    A = nullptr;
}

var_assignment ::= IDENTIFIER ASSIGN expression.


// Variable Decls

var_decl ::= VAR IDENTIFIER var_type_spec ASSIGN expression.
var_decl ::= LET IDENTIFIER var_type_spec ASSIGN expression.

var_type_spec ::= COLON type_specifier.
var_type_spec ::=.


// Expressions
expression ::= PAR_BEGIN expression PAR_END.
expression ::= expression AND expression.
expression ::= expression OR expression.
expression ::= NOT PAR_BEGIN expression PAR_END.
expression ::= expression PLUS expression.
expression ::= expression MINUS expression.
expression ::= expression MULT expression.
expression ::= expression DIV expression.
expression ::= expression MOD expression.
expression ::= expression ASSIGN expression.
expression ::= literal.

// Literals

literal ::= INTEGER_LITERAL.
literal ::= DECIMAL_LITERAL.


