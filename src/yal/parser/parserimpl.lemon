/*
 *  Copyright 2017 by Leander Beernaert (leanderbb@gmail.com)
 *
 *  This file is part of YAL.
 *
 *  YAL is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3
 *  of the License, or (at your option) any later version.
 *
 *  YAL is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with YAL. If not, see <http://www.gnu.org/licenses/>.
 */
%name YALParser

%token_prefix YAL_TOKEN_

%include {
#include <cassert>
#include <vector>
#include "yal/parser/parser.h"
#include "yal/parser/parserhelper.h"
#include "yal/util/log.h"
#include "yal/util/stringref.h"
#include "yal/ast/typebuiltin.h"
#include "yal/ast/declfunction.h"
#include "yal/ast/decltypefunction.h"
#include "yal/ast/declmodule.h"
#include "yal/ast/reftype.h"
#include "yal/ast/declvar.h"
#include "yal/ast/declparamvar.h"
#include "yal/ast/stmtexpression.h"
#include "yal/ast/stmtreturn.h"
#include "yal/ast/exprunaryoperator.h"
#include "yal/ast/exprbinaryoperator.h"
#include "yal/ast/statement.h"
#include "yal/ast/statementlist.h"
#include "yal/ast/exprintegerliteral.h"
#include "yal/ast/stmtreturn.h"
#include "yal/ast/exprboolliteral.h"
#include "yal/ast/stmtdecl.h"
#include "yal/lexer/lexer.h"
#include "yal/ast/stmtassign.h"
#include "yal/ast/exprvarref.h"
#include "yal/ast/declstruct.h"
#include "yal/ast/exprstructvarref.h"
#include "yal/ast/exprstructfncall.h"
#include "yal/ast/exprlist.h"
#define YYMALLOCARGTYPE size_t
}


%extra_argument { yal::Parser *pParser }

%syntax_error {

    pParser->logParseFailure();
    {
#if defined(YAL_DEBUG)
        yal::Log::MultiLineScope multiLineScope(pParser->getLog());
        pParser->getLog().error("Expected one of the following tokens:\n");
        int n = sizeof(yyTokenName) / sizeof(yyTokenName[0]);
        for (int i = 0; i < n; ++i) {
            int a = yy_find_shift_action(yypParser, (YYCODETYPE)i);
            if (a < YYNSTATE + YYNRULE) {
                pParser->getLog().error("%\n",yyTokenName[i]);
            }
        }
    }
#endif
}

%right ASSIGN.
%left OR.
%left AND.
%left BIT_OR BIT_XOR BIT_AND.
%nonassoc EQ NE GT LT GE LE.
%left PLUS MINUS.
%left MULT DIV MOD.
%right NEGATE.
%right BIT_NOT.
%right NOT.
%right DOT.

%type type_builtin {yal::RefTypeResolved*}
%type decl_function {yal::DeclFunction*}
%type type_function_decl {yal::DeclTypeFunction*}
%type decls {yal::DeclModule*}
%type module {yal::DeclModule*}
%type function_return_decl {yal::RefType*}
%type type_specifier {yal::RefType*}
%type var_type_spec {yal::RefType*}
%type named_decl {yal::StringRefPod}
%type function_args_decl {yal::DeclParamVarContainer*}
%type type_function_args_decl {yal::DeclParamVarContainer*}
%type type_function_args_decl_other {yal::DeclParamVarContainer*}
%type function_arg_decl {yal::DeclParamVar*}
%type statement_list {yal::StatementList*}
%type function_scope {yal::StatementList*}
%type statement {yal::Statement*}
%type expression {yal::StmtExpression*}
%type unaryexp {yal::ExprUnaryOperator*}
%type binaryexp {yal::ExprBinaryOperator*}
%type literal {yal::StmtExpression*}
%type var_decl {yal::StmtDecl*}
%type type_decl {yal::DeclStruct*}
%type type_var_decl {yal::DeclVar*}
%type type_var_decls {yal::DeclStructMembers*}
%type function_call_args{yal::ExprList*}
%type qualifier {uint32_t}
%type qualified_type {yal::RefType*}
%start_symbol  module
%token_type {yal::TokenInfo}


module ::= decls END.

decls (A)::= decls(B) type_decl(C). {
    A =B; B->addDecl(C);
}
decls(A) ::= decls(B) decl_function(C). {
        A =B; B->addDecl(C);
}
decls(A) ::= decls(B) type_function_decl(C). {
        A =B; B->addDecl(C);
}
decls(A) ::=. {
        A =  pParser->newAstNode<yal::DeclModule>();
        pParser->onAstNodeCreate(A);
     }

// Type References  -----------------------------------------------------------

type_specifier(A) ::= type_builtin(B). {A=B;}
type_specifier(A) ::= type_array. {A = nullptr;}
type_specifier(A) ::= IDENTIFIER(B). {
        A = pParser->newAstNode<yal::RefTypeUnresolved>(B.tokenStr);
 }

qualifier(A)::=. {A = 0;}
qualifier(A)::= MUT. {A = yal::parser::kQualifierMutable;}
qualifier(A)::= REFERENCE. {A = yal::parser::kQualifierReference;}
qualifier(A)::= MUT REFERENCE. {
        A = yal::parser::kQualifierReference | yal::parser::kQualifierMutable;
 }
qualified_type(A) ::= qualifier(D) type_specifier(C). {
        C->setQualifier(yal::parser::MakeQualifierFromFlags(D));
        A = C;
}

type_builtin(A) ::= TYPE_BOOL. {
        A = pParser->newAstNode<yal::RefTypeResolved>(pParser->getModule().getTypeContext().getTypeBuiltinBool());
        }
type_builtin(A) ::= TYPE_INT8. {
        A = pParser->newAstNode<yal::RefTypeResolved>(pParser->getModule().getTypeContext().getTypeBuiltinI8());
        }
type_builtin(A) ::= TYPE_UINT8. {
        A  = pParser->newAstNode<yal::RefTypeResolved>(pParser->getModule().getTypeContext().getTypeBuiltinU8());
        }
type_builtin(A) ::= TYPE_INT16. {
        A = pParser->newAstNode<yal::RefTypeResolved>(pParser->getModule().getTypeContext().getTypeBuiltinI16());
        }
type_builtin(A) ::= TYPE_UINT16. {
        A  = pParser->newAstNode<yal::RefTypeResolved>(pParser->getModule().getTypeContext().getTypeBuiltinU16());
        }
type_builtin(A) ::= TYPE_INT32. {
        A = pParser->newAstNode<yal::RefTypeResolved>(pParser->getModule().getTypeContext().getTypeBuiltinI32());
        }
type_builtin(A) ::= TYPE_UINT32. {
        A = pParser->newAstNode<yal::RefTypeResolved>(pParser->getModule().getTypeContext().getTypeBuiltinU32());
        }
type_builtin(A) ::= TYPE_INT64. {
        A = pParser->newAstNode<yal::RefTypeResolved>(pParser->getModule().getTypeContext().getTypeBuiltinI64());
        }
type_builtin(A) ::= TYPE_UINT64. {
        A = pParser->newAstNode<yal::RefTypeResolved>(pParser->getModule().getTypeContext().getTypeBuiltinU64());
        }
type_builtin(A) ::= TYPE_FLOAT. {
        A = pParser->newAstNode<yal::RefTypeResolved>(pParser->getModule().getTypeContext().getTypeBuiltinFloat());
        }
type_builtin(A) ::= TYPE_DOUBLE. {
        A = pParser->newAstNode<yal::RefTypeResolved>(pParser->getModule().getTypeContext().getTypeBuiltinDouble());
        }

type_array ::= type_builtin ARRAY_BEGIN ARRAY_END.

// Type Decl -----------------------------------------------------------------

type_decl(A) ::= TYPE IDENTIFIER(B) COLON STRUCT SCOPE_BEGIN type_var_decls(C) SCOPE_END. {
     A = pParser->newAstNode<yal::DeclStruct>(B.tokenStr, C);
}
type_decl(A) ::= TYPE IDENTIFIER COLON type_specifier SEMI_COLON. {
    A = nullptr;
}

type_var_decls(A) ::= type_var_decls(B) type_var_decl(C). {
    A = B;
    A->addDeclVar(C);
}
type_var_decls(A) ::= type_var_decl(B). {
    A = pParser->newAstNode<yal::DeclStructMembers>();
    A->addDeclVar(B);
}

type_var_decl(A) ::= IDENTIFIER(B) COLON qualified_type(C) ASSIGN expression(D) SEMI_COLON. {
    A = pParser->newAstNode<yal::DeclVar>(B.tokenStr, yal::Qualifier(), C, D);
}

// Function decl --------------------------------------------------------------

decl_function (A) ::= FUNCTION IDENTIFIER(B) PAR_BEGIN function_args_decl(D) PAR_END
        function_return_decl(C) function_scope(E). {
        A = pParser->newAstNode<yal::DeclFunction>(B.tokenStr, D, C, E);
        }


type_function_decl(A)::= FUNCTION type_specifier(B) COLON COLON IDENTIFIER(C)
        PAR_BEGIN type_function_args_decl(E) PAR_END
        function_return_decl(D) function_scope(F). {
            A = pParser->newAstNode<yal::DeclTypeFunction>(C.tokenStr, E, B, D, F);
        }        

// Type function args decl ---------------------------------------------------

type_function_args_decl(A) ::= qualifier(B) SELF. {
        A = pParser->newAstNode<yal::DeclParamVarContainer>();
        auto qualifier = yal::parser::MakeQualifierFromFlags(B);
        A->addDeclParam(pParser->newAstNode<yal::DeclParamVarSelf>(qualifier));
}

type_function_args_decl(A) ::= qualifier(C) SELF COMMA type_function_args_decl_other(B). {
    A = B;
    auto qualifier = yal::parser::MakeQualifierFromFlags(C);
    A->addDeclParam(pParser->newAstNode<yal::DeclParamVarSelf>(qualifier));
}

type_function_args_decl(A) ::= function_args_decl(B). {
        A = B;
}

type_function_args_decl_other(A) ::= type_function_args_decl_other(B) COMMA function_arg_decl(C). {
    A = B;
    A->addDeclParam(C);
}

type_function_args_decl_other(A) ::= function_arg_decl(C). {
        A = pParser->newAstNode<yal::DeclParamVarContainer>();
        A->addDeclParam(C);
}

// Function args decl --------------------------------------------------------

function_args_decl(A) ::= function_args_decl(B) COMMA function_arg_decl(C). {
        B->addDeclParam(C);
        A = B;
}

function_args_decl(A) ::= function_arg_decl(B). {
        A = pParser->newAstNode<yal::DeclParamVarContainer>();
        A->addDeclParam(B);
}
function_args_decl(A) ::= . {
        A = nullptr;
}

function_arg_decl(A) ::= IDENTIFIER(B) COLON qualified_type(C). {
    A = pParser->newAstNode<yal::DeclParamVar>(B.tokenStr, yal::Qualifier(),C);
}

function_return_decl(A) ::= COLON qualified_type(B). { A = B;}
function_return_decl(A)::=. {A = nullptr;}

function_scope(A)::= SCOPE_BEGIN SCOPE_END. { A = nullptr;}
function_scope(A)::= SCOPE_BEGIN statement_list(B) SCOPE_END. {A = B;}

// Statments -----------------------------------------------------------------
statement_list(A) ::= statement_list(B) statement(C).{
    B->addStatement(C);
    A=B;
}
statement_list(A) ::= statement(B). {
    A = pParser->newAstNode<yal::StatementList>();
    A->addStatement(B);
}


statement(A) ::= expression(B) ASSIGN expression(C) SEMI_COLON. {
   A = pParser->newAstNode<yal::StmtAssign>(B,C);
}
statement(A)::= var_decl(B) SEMI_COLON. {
    A = B;
}
statement(A) ::= expression(B) SEMI_COLON. {A = B;}
statement(A) ::= RETURN expression(B) SEMI_COLON. {
    A = pParser->newAstNode<yal::StmtReturn>(B);
}
statement(A) ::= RETURN SEMI_COLON. {
    A = pParser->newAstNode<yal::StmtReturn>();
}

// Var Decls -----------------------------------------------------------------

var_decl(A) ::= VAR IDENTIFIER(B) var_type_spec(C) ASSIGN expression(D). {
    auto varDecl = pParser->newAstNode<yal::DeclVar>(B.tokenStr, yal::Qualifier(), C, D);
    A= pParser->newAstNode<yal::StmtDecl>(varDecl);
}
var_decl(A) ::= LET IDENTIFIER(B) var_type_spec(C) ASSIGN expression(D). {
    yal::Qualifier qualifier;
    qualifier.setImmutable();
    auto varDecl = pParser->newAstNode<yal::DeclVar>(B.tokenStr, qualifier, C, D);
    A= pParser->newAstNode<yal::StmtDecl>(varDecl);
}

var_type_spec(A) ::= COLON qualified_type(B). {A = B;}
var_type_spec(A)::=. {A = nullptr;}


// Expressions- --------------------------------------------------------------

expression(A) ::= PAR_BEGIN expression(B) PAR_END. {A = B;}
expression(A) ::= literal(B). {A = B;}
expression (A) ::= unaryexp(B). {A = B;}
expression (A) ::= binaryexp(B). {A = B;}
expression (A) ::= IDENTIFIER(B). {
    A = pParser->newAstNode<yal::ExprVarRef>(B.tokenStr);
}
expression (A) ::= SELF. {
    A  = pParser->newAstNode<yal::ExprVarRefSelf>();
}

expression (A) ::= expression(B) DOT IDENTIFIER(C). {
    A = pParser->newAstNode<yal::ExprStructVarRef>(B, C.tokenStr);
}

expression(A) ::= IDENTIFIER(C) PAR_BEGIN function_call_args(D) PAR_END. {
    auto fnType = pParser->newAstNode<yal::RefTypeUnresolved>(C.tokenStr);
    A = pParser->newAstNode<yal::ExprFnCall>(fnType, D);
}

expression(A) ::= expression(B) DOT IDENTIFIER(C) PAR_BEGIN function_call_args(D) PAR_END. {
    auto fnType = pParser->newAstNode<yal::RefTypeUnresolved>(C.tokenStr);
    A = pParser->newAstNode<yal::ExprStructFnCall>(B, fnType, D);
}

// Binary operators ----------------------------------------------------------

binaryexp(A) ::= expression(B) AND expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::And,
                                                        B, C);
}
binaryexp(A) ::= expression(B) OR expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Or,
                                                        B, C);
}
binaryexp(A) ::= expression(B) PLUS expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Plus,
                                                        B, C);
}
binaryexp(A) ::= expression(B) MINUS expression(C).  {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Minus,
                                                        B, C);
}
binaryexp(A) ::= expression(B) MULT expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Mult,
                                                        B, C);
}
binaryexp(A) ::= expression(B) DIV expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Div,
                                                        B, C);
}
binaryexp(A) ::= expression(B) MOD expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Mod,
                                                        B, C);
}

binaryexp(A) ::= expression(B) EQ expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Eq,
                                                        B, C);
}

binaryexp(A) ::= expression(B) NE expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Ne,
                                                        B, C);
}

binaryexp(A) ::= expression(B) LE expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Le,
                                                        B, C);
}

binaryexp(A) ::= expression(B) LT expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Lt,
                                                        B, C);
}

binaryexp(A) ::= expression(B) GE expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Ge,
                                                        B, C);
}

binaryexp(A) ::= expression(B) GT expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Gt,
                                                        B, C);
}

// Unary operators -----------------------------------------------------------

unaryexp(A) ::= NOT expression(B). {
    A = pParser->newAstNode<yal::ExprUnaryOperator>(yal::UnaryOperatorType::Not,
                                               B);
}
unaryexp(A) ::= BIT_NOT expression(B). {
    A = pParser->newAstNode<yal::ExprUnaryOperator>(yal::UnaryOperatorType::BitNot,
                                               B);
}
unaryexp(A) ::= MINUS expression(B). [NEGATE] {
    A = pParser->newAstNode<yal::ExprUnaryOperator>(yal::UnaryOperatorType::Negate,
                                               B);
}

// Function call ------------------------------------------------------------

function_call_args(A) ::= function_call_args(B) COMMA expression(C). {
    A = B;
    A->addExpression(C);
}
function_call_args(A)::= expression(B). {
    A = pParser->newAstNode<yal::ExprList>();
    A->addExpression(B);
}
function_call_args(A) ::=. {
    A= nullptr;
}

// Literals ------------------------------------------------------------------

literal(A) ::= INTEGER_LITERAL(B). {
        A = pParser->newIntegerLiteral(B);
   }
literal ::= DECIMAL_LITERAL.
literal(A) ::= BOOL_LITERAL(B). {
        A = pParser->newAstNode<yal::ExprBoolLiteral>(B.tokenStr);
}


