/*
 *  Copyright 2017 by Leander Beernaert (leanderbb@gmail.com)
 *
 *  This file is part of YAL.
 *
 *  YAL is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3
 *  of the License, or (at your option) any later version.
 *
 *  YAL is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with YAL. If not, see <http://www.gnu.org/licenses/>.
 */
%name YALParser

%token_prefix YAL_TOKEN_

%include {
#include "yal/parser/parser.h"
#include "yal/util/log.h"
#include <cassert>
#include <vector>
#include "yal/ast/typebuiltin.h"
#include "yal/ast/declfunction.h"
#include "yal/ast/declmodule.h"
}


%extra_argument { yal::Parser *pParser }

%syntax_error {
    pParser->logParseFailure();
    pParser->getLog().error("Expected one of the following tokens:\n");
    {
        yal::Log::MultiLineScope multiLineScope(pParser->getLog());
        int n = sizeof(yyTokenName) / sizeof(yyTokenName[0]);
        for (int i = 0; i < n; ++i) {
            int a = yy_find_shift_action(yypParser, (YYCODETYPE)i);
            if (a < YYNSTATE + YYNRULE) {
                pParser->getLog().error("%s \n",yyTokenName[i]);
            }
        }
    }
}

%right ASSIGN.
%left OR.
%left AND.
%left BIT_OR.
%left BIT_XOR.
%left BIT_AND.
%nonassoc EQ NE GT LT GE LE.
%left PLUS MINUS.
%left MULT DIV MOD.
%right NEG.
%right NOT.
%right DOT.

%type type_builtin {const yal::TypeBuiltin*}
%type decl_function {yal::DeclFunction*}
%type decls {yal::DeclModule*}
%type module {yal::DeclModule*}

%start_symbol  module

module ::= decls END.

decls ::= decls type_decl.
decls(A) ::= decls(B) decl_function(C). {
        A =B; B->addDecl(C);
}
decls::= decls type_function_decl.
decls(A) ::=. {
        A =  pParser->newASTNode<yal::DeclModule>();
        pParser->onNode(A);
     }
// Type  specifiers
type_specifier ::= type_builtin.
type_specifier ::= type_array.
type_specifier ::= IDENTIFIER.

type_builtin(A) ::= TYPE_BOOL. {A = yal::TypeBuiltin::GetTypeForDataType(yal::TypeBuiltin::DataType::Boolean);}
type_builtin(A) ::= TYPE_INT8. {A = yal::TypeBuiltin::GetTypeForDataType(yal::TypeBuiltin::DataType::Int8);}
type_builtin(A) ::= TYPE_UINT8. {A = yal::TypeBuiltin::GetTypeForDataType(yal::TypeBuiltin::DataType::UInt8);}
type_builtin(A) ::= TYPE_INT16. {A = yal::TypeBuiltin::GetTypeForDataType(yal::TypeBuiltin::DataType::Int16);}
type_builtin(A) ::= TYPE_UINT16. {A = yal::TypeBuiltin::GetTypeForDataType(yal::TypeBuiltin::DataType::UInt16);}
type_builtin(A) ::= TYPE_INT32. {A = yal::TypeBuiltin::GetTypeForDataType(yal::TypeBuiltin::DataType::Int32);}
type_builtin(A) ::= TYPE_UINT32. {A = yal::TypeBuiltin::GetTypeForDataType(yal::TypeBuiltin::DataType::UInt32);}
type_builtin(A) ::= TYPE_INT64. {A = yal::TypeBuiltin::GetTypeForDataType(yal::TypeBuiltin::DataType::Int64);}
type_builtin(A) ::= TYPE_UINT64. {A = yal::TypeBuiltin::GetTypeForDataType(yal::TypeBuiltin::DataType::UInt64);}
type_builtin(A) ::= TYPE_FLOAT. {A = yal::TypeBuiltin::GetTypeForDataType(yal::TypeBuiltin::DataType::Float);}
type_builtin(A) ::= TYPE_DOUBLE. {A = yal::TypeBuiltin::GetTypeForDataType(yal::TypeBuiltin::DataType::Double);}

type_array ::= type_builtin ARRAY_BEGIN ARRAY_END.

// custom type declaration
type_decl ::= TYPE IDENTIFIER COLON STRUCT SCOPE_BEGIN type_var_decls SCOPE_END.
type_decl ::= TYPE IDENTIFIER COLON type_specifier SEMI_COLON.

type_var_decls ::= type_var_decls type_var_decl.
type_var_decls ::= type_var_decl.

type_var_decl ::= IDENTIFIER COLON type_specifier SEMI_COLON.

// Functions

decl_function (A) ::= FUNCTION IDENTIFIER PAR_BEGIN function_args_decl PAR_END
        function_return_decl function_scope. {
        A = pParser->newASTNode<yal::DeclFunction>();
        pParser->onNode(A);
        }


type_function_decl::= FUNCTION type_specifier COLON COLON IDENTIFIER
        PAR_BEGIN function_args_decl PAR_END
        function_return_decl function_scope.


function_args_decl ::= function_args_decl COMMA function_arg_decl.
function_args_decl ::= function_arg_decl.
function_args_decl ::= .

function_arg_decl ::= IDENTIFIER COLON type_specifier.

function_return_decl ::= COLON type_specifier.
function_return_decl ::=.

function_scope ::= SCOPE_BEGIN SCOPE_END.
function_scope ::= SCOPE_BEGIN statement_list SCOPE_END.

// Statements
statement_list ::= statement_list statement.
statement_list ::= statement.


statement ::= var_assignment SEMI_COLON.
statement ::= var_decl SEMI_COLON.

var_assignment ::= IDENTIFIER ASSIGN expression.


// Variable Decls

var_decl ::= VAR IDENTIFIER var_type_spec ASSIGN expression.
var_decl ::= LET IDENTIFIER var_type_spec ASSIGN expression.

var_type_spec ::= COLON type_specifier.
var_type_spec ::=.


// Expressions
expression ::= PAR_BEGIN expression PAR_END.
expression ::= expression AND expression.
expression ::= expression OR expression.
expression ::= NOT PAR_BEGIN expression PAR_END.
expression ::= expression PLUS expression.
expression ::= expression MINUS expression.
expression ::= expression MULT expression.
expression ::= expression DIV expression.
expression ::= expression MOD expression.
expression ::= expression ASSIGN expression.
expression ::= literal.

// Literals

literal ::= INTEGER_LITERAL.
literal ::= DECIMAL_LITERAL.


