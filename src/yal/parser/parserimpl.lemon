/*
 *  Copyright 2017 by Leander Beernaert (leanderbb@gmail.com)
 *
 *  This file is part of YAL.
 *
 *  YAL is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3
 *  of the License, or (at your option) any later version.
 *
 *  YAL is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with YAL. If not, see <http://www.gnu.org/licenses/>.
 */
%name YALParser

%token_prefix YAL_TOKEN_

%include {
#include <cassert>
#include <vector>
#include "yal/parser/parser.h"
#include "yal/util/log.h"
#include "yal/util/stringref.h"
#include "yal/ast/typebuiltin.h"
#include "yal/ast/declfunction.h"
#include "yal/ast/decltypefunction.h"
#include "yal/ast/declmodule.h"
#include "yal/ast/reftypebuiltin.h"
#include "yal/ast/reftypeidentifier.h"
#include "yal/ast/declvar.h"
#include "yal/ast/declparamvar.h"
#include "yal/ast/stmtexpression.h"
#include "yal/ast/stmtreturn.h"
#include "yal/ast/exprunaryoperator.h"
#include "yal/ast/exprbinaryoperator.h"
#include "yal/ast/statement.h"
#include "yal/ast/statementlist.h"
#include "yal/ast/exprintegerliteral.h"
#include "yal/ast/stmtreturn.h"
#include "yal/ast/exprboolliteral.h"
#include "yal/ast/stmtdecl.h"
#include "yal/lexer/lexer.h"
#include "yal/ast/stmtassign.h"
#include "yal/ast/exprvarref.h"
#define YYMALLOCARGTYPE size_t
}


%extra_argument { yal::Parser *pParser }

%syntax_error {

    pParser->logParseFailure();
    {
        yal::Log::MultiLineScope multiLineScope(pParser->getLog());
        pParser->getLog().error("Expected one of the following tokens:\n");
        int n = sizeof(yyTokenName) / sizeof(yyTokenName[0]);
        for (int i = 0; i < n; ++i) {
            int a = yy_find_shift_action(yypParser, (YYCODETYPE)i);
            if (a < YYNSTATE + YYNRULE) {
                pParser->getLog().error("%\n",yyTokenName[i]);
            }
        }
    }
}

%right ASSIGN.
%left OR.
%left AND.
%left BIT_OR BIT_XOR BIT_AND.
%nonassoc EQ NE GT LT GE LE.
%left PLUS MINUS.
%left MULT DIV MOD.
%right NEGATE.
%right BIT_NOT.
%right NOT.
%right DOT.

%type type_builtin {yal::RefTypeBuiltin*}
%type decl_function {yal::DeclFunction*}
%type type_function_decl {yal::DeclTypeFunction*}
%type decls {yal::DeclModule*}
%type module {yal::DeclModule*}
%type function_return_decl {yal::RefType*}
%type type_specifier {yal::RefType*}
%type var_type_spec {yal::RefType*}
%type named_decl {yal::StringRefPod}
%type function_args_decl {yal::DeclParamVarContainer*}
%type function_arg_decl {yal::DeclParamVar*}
%type statement_list {yal::StatementList*}
%type function_scope {yal::StatementList*}
%type statement {yal::Statement*}
%type expression {yal::StmtExpression*}
%type unaryexp {yal::ExprUnaryOperator*}
%type binaryexp {yal::ExprBinaryOperator*}
%type literal {yal::StmtExpression*}
%type var_decl {yal::StmtDecl*}
%start_symbol  module
%token_type {yal::TokenInfo}


module ::= decls END.

decls ::= decls type_decl.
decls(A) ::= decls(B) decl_function(C). {
        A =B; B->addDecl(C);
}
decls(A) ::= decls(B) type_function_decl(C). {
        A =B; B->addDecl(C);
}
decls(A) ::=. {
        A =  pParser->newAstNode<yal::DeclModule>();
        pParser->onAstNodeCreate(A);
     }
// Type  specifiers
type_specifier(A) ::= type_builtin(B). {A=B;}
type_specifier(A) ::= type_array. {A = nullptr;}
type_specifier(A) ::= IDENTIFIER(B). {A = pParser->newAstNode<yal::RefTypeIdentifier>(B.tokenStr);}

type_builtin(A) ::= TYPE_BOOL. {
        A = pParser->newAstNode<yal::RefTypeBuiltin>(pParser->getModule().getTypeContext().getTypeBuiltinBool());
        }
type_builtin(A) ::= TYPE_INT8. {
        A = pParser->newAstNode<yal::RefTypeBuiltin>(pParser->getModule().getTypeContext().getTypeBuiltinI8());
        }
type_builtin(A) ::= TYPE_UINT8. {
        A  = pParser->newAstNode<yal::RefTypeBuiltin>(pParser->getModule().getTypeContext().getTypeBuiltinU8());
        }
type_builtin(A) ::= TYPE_INT16. {
        A = pParser->newAstNode<yal::RefTypeBuiltin>(pParser->getModule().getTypeContext().getTypeBuiltinI16());
        }
type_builtin(A) ::= TYPE_UINT16. {
        A  = pParser->newAstNode<yal::RefTypeBuiltin>(pParser->getModule().getTypeContext().getTypeBuiltinU16());
        }
type_builtin(A) ::= TYPE_INT32. {
        A = pParser->newAstNode<yal::RefTypeBuiltin>(pParser->getModule().getTypeContext().getTypeBuiltinI32());
        }
type_builtin(A) ::= TYPE_UINT32. {
        A = pParser->newAstNode<yal::RefTypeBuiltin>(pParser->getModule().getTypeContext().getTypeBuiltinU32());
        }
type_builtin(A) ::= TYPE_INT64. {
        A = pParser->newAstNode<yal::RefTypeBuiltin>(pParser->getModule().getTypeContext().getTypeBuiltinI64());
        }
type_builtin(A) ::= TYPE_UINT64. {
        A = pParser->newAstNode<yal::RefTypeBuiltin>(pParser->getModule().getTypeContext().getTypeBuiltinU64());
        }
type_builtin(A) ::= TYPE_FLOAT. {
        A = pParser->newAstNode<yal::RefTypeBuiltin>(pParser->getModule().getTypeContext().getTypeBuiltinFloat());
        }
type_builtin(A) ::= TYPE_DOUBLE. {
        A = pParser->newAstNode<yal::RefTypeBuiltin>(pParser->getModule().getTypeContext().getTypeBuiltinDouble());
        }

type_array ::= type_builtin ARRAY_BEGIN ARRAY_END.

// custom type declaration
type_decl ::= TYPE IDENTIFIER COLON STRUCT SCOPE_BEGIN type_var_decls SCOPE_END.
type_decl ::= TYPE IDENTIFIER COLON type_specifier SEMI_COLON.

type_var_decls ::= type_var_decls type_var_decl.
type_var_decls ::= type_var_decl.

type_var_decl ::= IDENTIFIER COLON type_specifier SEMI_COLON.

// Functions

decl_function (A) ::= FUNCTION IDENTIFIER(B) PAR_BEGIN function_args_decl(D) PAR_END
        function_return_decl(C) function_scope(E). {
        A = pParser->newAstNode<yal::DeclFunction>(B.tokenStr, D, C, E);
        }


type_function_decl(A)::= FUNCTION type_specifier(B) COLON COLON IDENTIFIER(C)
        PAR_BEGIN function_args_decl(E) PAR_END
        function_return_decl(D) function_scope(F). {
            A = pParser->newAstNode<yal::DeclTypeFunction>(C.tokenStr, E, B, D, F);
        }


function_args_decl(A) ::= function_args_decl(B) COMMA function_arg_decl(C). {
        B->addDeclParam(C);
        A = B;
}
function_args_decl(A) ::= function_arg_decl(B). {
        A = pParser->newAstNode<yal::DeclParamVarContainer>();
        A->addDeclParam(B);
}
function_args_decl(A) ::= . {
        A = nullptr;
}

function_arg_decl(A) ::= IDENTIFIER(B) COLON type_specifier(C). {
    A = pParser->newAstNode<yal::DeclParamVar>(B.tokenStr, yal::Qualifier(),C);
}

function_return_decl(A) ::= COLON type_specifier(B). { A = B;}
function_return_decl(A)::=. {A = nullptr;}

function_scope(A)::= SCOPE_BEGIN SCOPE_END. { A = nullptr;}
function_scope(A)::= SCOPE_BEGIN statement_list(B) SCOPE_END. {A = B;}

// Statements
statement_list(A) ::= statement_list(B) statement(C).{
    B->addStatement(C);
    A=B;
}
statement_list(A) ::= statement(B). {
    A = pParser->newAstNode<yal::StatementList>();
    A->addStatement(B);
}


statement(A) ::= expression(B) ASSIGN expression(C) SEMI_COLON. {
   A = pParser->newAstNode<yal::StmtAssign>(B,C);
}
statement(A)::= var_decl(B) SEMI_COLON. {
    A = B;
}
statement(A) ::= expression(B) SEMI_COLON. {A = B;}
statement(A) ::= RETURN expression(B) SEMI_COLON. {
    A = pParser->newAstNode<yal::StmtReturn>(B);
}
statement(A) ::= RETURN SEMI_COLON. {
    A = pParser->newAstNode<yal::StmtReturn>();
}

// Variable Decls

var_decl(A) ::= VAR IDENTIFIER(B) var_type_spec(C) ASSIGN expression(D). {
    auto varDecl = pParser->newAstNode<yal::DeclVar>(B.tokenStr, yal::Qualifier(), C, D);
    A= pParser->newAstNode<yal::StmtDecl>(varDecl);
}
var_decl(A) ::= LET IDENTIFIER(B) var_type_spec(C) ASSIGN expression(D). {
    yal::Qualifier qualifier;
    qualifier.setImmutable();
    auto varDecl = pParser->newAstNode<yal::DeclVar>(B.tokenStr, qualifier, C, D);
    A= pParser->newAstNode<yal::StmtDecl>(varDecl);
}

var_type_spec(A) ::= COLON type_specifier(B). {A = B;}
var_type_spec(A)::=. {A = nullptr;}


// Expressions


expression(A) ::= PAR_BEGIN expression(B) PAR_END. {A = B;}
expression(A) ::= literal(B). {A = B;}
expression (A) ::= unaryexp(B). {A = B;}
expression (A) ::= binaryexp(B). {A = B;}
expression (A) ::= IDENTIFIER(B). {
    A = pParser->newAstNode<yal::ExprVarRef>(B.tokenStr);
}

binaryexp(A) ::= expression(B) AND expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::And,
                                                        B, C);
}
binaryexp(A) ::= expression(B) OR expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Or,
                                                        B, C);
}
binaryexp(A) ::= expression(B) PLUS expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Plus,
                                                        B, C);
}
binaryexp(A) ::= expression(B) MINUS expression(C).  {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Minus,
                                                        B, C);
}
binaryexp(A) ::= expression(B) MULT expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Mult,
                                                        B, C);
}
binaryexp(A) ::= expression(B) DIV expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Div,
                                                        B, C);
}
binaryexp(A) ::= expression(B) MOD expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Mod,
                                                        B, C);
}

unaryexp(A) ::= NOT expression(B). {
    A = pParser->newAstNode<yal::ExprUnaryOperator>(yal::UnaryOperatorType::Not,
                                               B);
}
unaryexp(A) ::= BIT_NOT expression(B). {
    A = pParser->newAstNode<yal::ExprUnaryOperator>(yal::UnaryOperatorType::BitNot,
                                               B);
}
unaryexp(A) ::= MINUS expression(B). [NEGATE] {
    A = pParser->newAstNode<yal::ExprUnaryOperator>(yal::UnaryOperatorType::Negate,
                                               B);
}

// Literals

literal(A) ::= INTEGER_LITERAL(B). {
        A = pParser->newIntegerLiteral(B);
   }
literal ::= DECIMAL_LITERAL.
literal(A) ::= BOOL_LITERAL(B). {
        A = pParser->newAstNode<yal::ExprBoolLiteral>(B.tokenStr);
}


