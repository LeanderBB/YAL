/*
 *  Copyright 2017 by Leander Beernaert (leanderbb@gmail.com)
 *
 *  This file is part of YAL.
 *
 *  YAL is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3
 *  of the License, or (at your option) any later version.
 *
 *  YAL is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with YAL. If not, see <http://www.gnu.org/licenses/>.
 */
%name YALParser

%token_prefix YAL_TOKEN_

%include {
#include <cassert>
#include <vector>
#include "yal/parser/parser.h"
#include "yal/parser/parserhelper.h"
#include "yal/util/log.h"
#include "yal/util/stringref.h"
#include "yal/ast/module.h"
#include "yal/ast/typebuiltin.h"
#include "yal/ast/declfunction.h"
#include "yal/ast/decltypefunction.h"
#include "yal/ast/declmodule.h"
#include "yal/ast/reftype.h"
#include "yal/ast/declvar.h"
#include "yal/ast/declparamvar.h"
#include "yal/ast/stmtexpression.h"
#include "yal/ast/stmtreturn.h"
#include "yal/ast/exprunaryoperator.h"
#include "yal/ast/exprbinaryoperator.h"
#include "yal/ast/statement.h"
#include "yal/ast/statementlist.h"
#include "yal/ast/exprintegerliteral.h"
#include "yal/ast/stmtreturn.h"
#include "yal/ast/exprboolliteral.h"
#include "yal/ast/stmtdecl.h"
#include "yal/lexer/lexer.h"
#include "yal/ast/stmtassign.h"
#include "yal/ast/exprvarref.h"
#include "yal/ast/declstruct.h"
#include "yal/ast/exprstructvarref.h"
#include "yal/ast/exprstructfncall.h"
#include "yal/ast/exprlist.h"
#include "yal/ast/exprdecimalliteral.h"
#define YYMALLOCARGTYPE size_t
}


%extra_argument { yal::Parser *pParser }

%syntax_error {

    pParser->logParseFailure();
    {
#if defined(YAL_DEBUG)
        yal::Log::MultiLineScope multiLineScope(pParser->getLog());
        pParser->getLog().error("Expected one of the following tokens:\n");
        int n = sizeof(yyTokenName) / sizeof(yyTokenName[0]);
        for (int i = 0; i < n; ++i) {
            int a = yy_find_shift_action(yypParser, (YYCODETYPE)i);
            if (a < YYNSTATE + YYNRULE) {
                pParser->getLog().error("%\n",yyTokenName[i]);
            }
        }
    }
#endif
}

%right ASSIGN.
%left OR.
%left AND.
%left BIT_OR BIT_XOR BIT_AND.
%nonassoc EQ NE GT LT GE LE.
%left PLUS MINUS.
%left MULT DIV MOD.
%right NEGATE.
%right BIT_NOT.
%right NOT.
%right DOT.

%type type_builtin {yal::RefType*}
%type decl_function {yal::DeclFunction*}
%type type_function_decl {yal::DeclTypeFunction*}
%type decls {yal::DeclModule*}
%type module {yal::DeclModule*}
%type function_return_decl {yal::RefType*}
%type type_specifier {yal::RefType*}
%type var_type_spec {yal::RefType*}
%type named_decl {yal::StringRefPod}
%type function_args_decl {yal::DeclParamVarContainer*}
%type type_function_args_decl {yal::DeclParamVarContainer*}
%type type_function_args_decl_other {yal::DeclParamVarContainer*}
%type function_arg_decl {yal::DeclParamVar*}
%type function_header {yal::DeclFunction*}
%type function_start {yal::DeclFunction*}
%type function_param_list {yal::DeclParamVarContainer*}
%type type_function_header {yal::DeclTypeFunction*}
%type type_function_start {yal::DeclTypeFunction*}
%type type_function_param_list {yal::DeclParamVarContainer*}
%type statement_list {yal::StatementList*}
%type statement_list_or_empty {yal::StatementList*}
%type statement {yal::Statement*}
%type expression {yal::StmtExpression*}
%type unaryexp {yal::ExprUnaryOperator*}
%type binaryexp {yal::ExprBinaryOperator*}
%type literal {yal::StmtExpression*}
%type decl_var {yal::StmtDecl*}
%type decl_type {yal::DeclBase*}
%type decl_struct {yal::DeclStruct*}
%type struct_header {yal::DeclStruct*}
%type struct_decl_var {yal::DeclVar*}
%type struct_decl_vars {yal::DeclStructMembers*}
%type function_call_args{yal::ExprList*}
%type qualifier {uint32_t}
%type qualified_type {yal::RefType*}
%start_symbol  module
%token_type {yal::TokenInfo}


module ::= decls END.

decls (A)::= decls(B) decl_type(C). {
    A =B; B->addDecl(C);
}
decls(A) ::= decls(B) decl_function(C). {
        A =B; B->addDecl(C);
}
decls(A) ::= decls(B) type_function_decl(C). {
        A =B; B->addDecl(C);
}
decls(A) ::=. {
        A =  pParser->getModule().getDeclNode();
     }

// Type References  -----------------------------------------------------------

type_specifier(A) ::= type_builtin(B). {A=B;}
type_specifier(A) ::= type_array. {A = nullptr;}
type_specifier(A) ::= IDENTIFIER(B). {
    auto type = pParser->resolveType(B);
    if (type != nullptr) {
        A = pParser->newAstNode<yal::RefType>(type);
        auto srcInfo = pParser->createSourceInfo(B, B);
        A->setSourceInfo(srcInfo);
    } else {
        A = nullptr;
    }
}

qualifier(A)::=. {A = 0;}
qualifier(A)::= MUT. {A = yal::parser::kQualifierMutable;}
qualifier(A)::= REFERENCE. {A = yal::parser::kQualifierReference;}
qualifier(A)::= MUT REFERENCE. {
        A = yal::parser::kQualifierReference | yal::parser::kQualifierMutable;
 }
qualified_type(A) ::= qualifier(D) type_specifier(C). {
    C->setQualifier(yal::parser::MakeQualifierFromFlags(D));
    A = C;
}

type_builtin(A) ::= TYPE_BOOL. {
    A = pParser->newAstNode<yal::RefType>(pParser->getModule().getTypeContext().getTypeBuiltinBool());
    }
type_builtin(A) ::= TYPE_INT8. {
    A = pParser->newAstNode<yal::RefType>(pParser->getModule().getTypeContext().getTypeBuiltinI8());
    }
type_builtin(A) ::= TYPE_UINT8. {
    A  = pParser->newAstNode<yal::RefType>(pParser->getModule().getTypeContext().getTypeBuiltinU8());
    }
type_builtin(A) ::= TYPE_INT16. {
    A = pParser->newAstNode<yal::RefType>(pParser->getModule().getTypeContext().getTypeBuiltinI16());
    }
type_builtin(A) ::= TYPE_UINT16. {
    A  = pParser->newAstNode<yal::RefType>(pParser->getModule().getTypeContext().getTypeBuiltinU16());
    }
type_builtin(A) ::= TYPE_INT32. {
    A = pParser->newAstNode<yal::RefType>(pParser->getModule().getTypeContext().getTypeBuiltinI32());
    }
type_builtin(A) ::= TYPE_UINT32. {
    A = pParser->newAstNode<yal::RefType>(pParser->getModule().getTypeContext().getTypeBuiltinU32());
    }
type_builtin(A) ::= TYPE_INT64. {
    A = pParser->newAstNode<yal::RefType>(pParser->getModule().getTypeContext().getTypeBuiltinI64());
    }
type_builtin(A) ::= TYPE_UINT64. {
    A = pParser->newAstNode<yal::RefType>(pParser->getModule().getTypeContext().getTypeBuiltinU64());
    }
type_builtin(A) ::= TYPE_FLOAT. {
    A = pParser->newAstNode<yal::RefType>(pParser->getModule().getTypeContext().getTypeBuiltinFloat());
    }
type_builtin(A) ::= TYPE_DOUBLE. {
    A = pParser->newAstNode<yal::RefType>(pParser->getModule().getTypeContext().getTypeBuiltinDouble());
    }

type_array ::= type_builtin ARRAY_BEGIN ARRAY_END.

// Type Decl -----------------------------------------------------------------

decl_type(A) ::= TYPE IDENTIFIER COLON type_specifier SEMI_COLON. {
    A = nullptr;
}

decl_type(A) ::= decl_struct(B). { A = B;}


// Decl Struct ---------------------------------------------------------------
struct_header(A) ::= TYPE(B) IDENTIFIER(C) COLON STRUCT. {
    A = pParser->newAstNode<yal::DeclStruct>(C.tokenStr);
    A->setSourceInfo(pParser->createSourceInfo(B, C));
    pParser->onDeclBegin(A);
}

decl_struct(A) ::= struct_header(B) SCOPE_BEGIN struct_decl_vars(C) SCOPE_END(Z). {
    A = B;
    if (C != nullptr) {
        C->updateSourceInfo();
        A->setMembers(C);
    }
    auto srcInfo = pParser->createSourceInfo(B->getSourceInfo(), Z);
    A->setSourceInfo(srcInfo);
    pParser->onDeclEnd();
}

struct_decl_vars(A) ::= struct_decl_vars(B) struct_decl_var(C). {
    A = B;
    if (pParser->onDecl(C)) {
        A->addDeclVar(C);
    }
}
struct_decl_vars(A) ::= struct_decl_var(B). {
    A = pParser->newAstNode<yal::DeclStructMembers>();
    if (pParser->onDecl(B)) {
        A->addDeclVar(B);
    }
}

struct_decl_var(A) ::= IDENTIFIER(B) COLON qualified_type(C) ASSIGN expression(D) SEMI_COLON(Z). {
    A = pParser->newAstNode<yal::DeclVar>(B.tokenStr, yal::Qualifier(), C, D);
    auto srcInfo = pParser->createSourceInfo(B, Z);
    A->setSourceInfo(srcInfo);
}

// Function decl --------------------------------------------------------------
        
        
function_header(A)::= function_start(B) function_param_list(C) function_return_decl (D). {
    A = B;
    A->setParams(C);
    A->setReturnType(D);

}

function_start(A)::= FUNCTION(B) IDENTIFIER(C). {
     A = pParser->newAstNode<yal::DeclFunction>(C.tokenStr);
     A->setSourceInfo(pParser->createSourceInfo(B, C));
     pParser->onDeclBegin(A);
}

function_param_list(A) ::= PAR_BEGIN function_args_decl (B) PAR_END. {
    A = B;
}

decl_function(A) ::= function_header(B) SCOPE_BEGIN statement_list_or_empty(C) SCOPE_END(D). {
    A = B;
    A->setFunctionBody(C);
    A->setSourceInfo(pParser->createSourceInfo(B->getSourceInfo(), D));
    pParser->onDeclEnd();
}

// Type Function decl ---------------------------------------------------------

type_function_header (A) ::= type_function_start(B) type_function_param_list(C) function_return_decl (D). {
    A = B;
    A->setParams(C);
    A->setReturnType(D);
}

type_function_start(A) ::= FUNCTION(B) type_specifier(C) COLON COLON IDENTIFIER(D). {
    A = pParser->newAstNode<yal::DeclTypeFunction>(D.tokenStr, C);
    A->setSourceInfo(pParser->createSourceInfo(B, D));
    pParser->onDeclBegin(A);
}

type_function_param_list(A) ::= PAR_BEGIN type_function_args_decl(B) PAR_END. {
    A = B;
}

type_function_decl(A)::= type_function_header(B) SCOPE_BEGIN statement_list_or_empty(C) SCOPE_END(D). {
    A = B;
    A->setFunctionBody(C);
    A->setSourceInfo(pParser->createSourceInfo(B->getSourceInfo(), D));
    pParser->onDeclEnd();
}


// Type function args decl ---------------------------------------------------

type_function_args_decl(A) ::= qualifier(B) SELF(C). {
        A = pParser->newAstNode<yal::DeclParamVarContainer>();
        auto qualifier = yal::parser::MakeQualifierFromFlags(B);
        auto refType = pParser->newAstNode<yal::RefType>(qualifier, pParser->resolveSelfType());
        auto selfVar = pParser->newAstNode<yal::DeclParamVarSelf>(refType);
        auto srcInfo = pParser->createSourceInfo(C, C);
        selfVar->setSourceInfo(srcInfo);
        A->addDeclParam(selfVar);
        pParser->onDecl(selfVar);
}

type_function_args_decl(A) ::= qualifier(C) SELF(Z) COMMA type_function_args_decl_other(B). {
    A = B;
    auto qualifier = yal::parser::MakeQualifierFromFlags(C);
    auto refType = pParser->newAstNode<yal::RefType>(qualifier, pParser->resolveSelfType());
    auto selfVar = pParser->newAstNode<yal::DeclParamVarSelf>(refType);
    auto srcInfo = pParser->createSourceInfo(Z, Z);
    selfVar->setSourceInfo(srcInfo);
    A->addDeclParam(selfVar);
    pParser->onDecl(selfVar);
}

type_function_args_decl(A) ::= function_args_decl(B). {
        A = B;
}

type_function_args_decl_other(A) ::= type_function_args_decl_other(B) COMMA function_arg_decl(C). {
    A = B;
    A->addDeclParam(C);
}

type_function_args_decl_other(A) ::= function_arg_decl(C). {
        A = pParser->newAstNode<yal::DeclParamVarContainer>();
        A->addDeclParam(C);
}

// Function args decl --------------------------------------------------------

function_args_decl(A) ::= function_args_decl(B) COMMA function_arg_decl(C). {
    if (pParser->onDecl(C)){
        B->addDeclParam(C);
        A = B;
    }
}

function_args_decl(A) ::= function_arg_decl(B). {
    if (pParser->onDecl(B)){
        A = pParser->newAstNode<yal::DeclParamVarContainer>();
        A->addDeclParam(B);
    }
}
function_args_decl(A) ::= . {
        A = nullptr;
}

function_arg_decl(A) ::= IDENTIFIER(B) COLON qualified_type(C). {
    A = pParser->newAstNode<yal::DeclParamVar>(B.tokenStr, yal::Qualifier(),C);
    auto srcInfo = pParser->createSourceInfo(B, C->getSourceInfo());
    A->setSourceInfo(srcInfo);
}

function_return_decl(A) ::= COLON qualified_type(B). { A = B;
}
function_return_decl(A)::=. {A = nullptr;}

// Statments -----------------------------------------------------------------

statement_list_or_empty(A) ::=. {A = nullptr;}
statement_list_or_empty(A) ::= statement_list(B). {A = B;}


statement_list(A) ::= statement_list(B) statement(C).{
    B->addStatement(C);
    A=B;
}
statement_list(A) ::= statement(B). {
    A = pParser->newAstNode<yal::StatementList>();
    A->addStatement(B);
}


statement(A) ::= expression(B) ASSIGN expression(C) SEMI_COLON. {
   A = pParser->newAstNode<yal::StmtAssign>(B,C);
}
statement(A)::= decl_var(B) SEMI_COLON. {
    A = B;
}
statement(A) ::= expression(B) SEMI_COLON. {A = B;}
statement(A) ::= RETURN(Z) expression(B) SEMI_COLON. {
    A = pParser->newAstNode<yal::StmtReturn>(B);
    auto srcInfo = pParser->createSourceInfo(Z, B->getSourceInfo());
    A->setSourceInfo(srcInfo);
}
statement(A) ::= RETURN(Z) SEMI_COLON. {
    A = pParser->newAstNode<yal::StmtReturn>();
    auto srcInfo = pParser->createSourceInfo(Z,Z);
    A->setSourceInfo(srcInfo);
}

// Var Decls -----------------------------------------------------------------

decl_var(A) ::= VAR(Z) IDENTIFIER(B) var_type_spec(C) ASSIGN expression(D). {
    auto varDecl = pParser->newAstNode<yal::DeclVar>(B.tokenStr, yal::Qualifier(), C, D);
    auto varSrcInfo = pParser->createSourceInfo(Z, B);
    varDecl->setSourceInfo(varSrcInfo);
    if (pParser->onDecl(varDecl)) {
        A= pParser->newAstNode<yal::StmtDecl>(varDecl);
        auto srcInfo = pParser->createSourceInfo(Z, D->getSourceInfo());
        A->setSourceInfo(srcInfo);
    }

}
decl_var(A) ::= LET(Z) IDENTIFIER(B) var_type_spec(C) ASSIGN expression(D). {
    yal::Qualifier qualifier;
    qualifier.setImmutable();
    auto varDecl = pParser->newAstNode<yal::DeclVar>(B.tokenStr, qualifier, C, D);
    auto varSrcInfo = pParser->createSourceInfo(Z, B);
    varDecl->setSourceInfo(varSrcInfo);
    if (pParser->onDecl(varDecl)) {
        A= pParser->newAstNode<yal::StmtDecl>(varDecl);
        auto srcInfo = pParser->createSourceInfo(Z, D->getSourceInfo());
        A->setSourceInfo(srcInfo);
    }
}

var_type_spec(A) ::= COLON qualified_type(B). {A = B;}
var_type_spec(A)::=. {A = nullptr;}


// Expressions- --------------------------------------------------------------

expression(A) ::= PAR_BEGIN expression(B) PAR_END. {A = B;}
expression(A) ::= literal(B). {A = B;}
expression (A) ::= unaryexp(B). {A = B;}
expression (A) ::= binaryexp(B). {A = B;}
expression (A) ::= IDENTIFIER(B). {
    A = pParser->newAstNode<yal::ExprVarRef>(B.tokenStr);
    auto srcInfo = pParser->createSourceInfo(B, B);
    A->setSourceInfo(srcInfo);
}
expression (A) ::= SELF(Z). {
    A  = pParser->newAstNode<yal::ExprVarRefSelf>();
    auto srcInfo = pParser->createSourceInfo(Z, Z);
    A->setSourceInfo(srcInfo);
}

expression (A) ::= expression(B) DOT IDENTIFIER(C). {
    A = pParser->newAstNode<yal::ExprStructVarRef>(B, C.tokenStr);
    auto srcInfo = pParser->createSourceInfo(B->getSourceInfo(), C);
    A->setSourceInfo(srcInfo);
}

expression(A) ::= IDENTIFIER(C) PAR_BEGIN function_call_args(D) PAR_END(Z). {
    auto type = pParser->resolveType(C);
    if (type != nullptr ) {
        auto fnType = pParser->newAstNode<yal::RefType>(type);
        auto fnSrcInfo = pParser->createSourceInfo(C, C);
        fnType->setSourceInfo(fnSrcInfo);
        if (D != nullptr) {
            D->updateSourceInfo();
        }
        A = pParser->newAstNode<yal::ExprFnCall>(fnType, D);
        auto srcInfo = pParser->createSourceInfo(C, Z);
        A->setSourceInfo(srcInfo);
    }
}

expression(A) ::= expression(B) DOT IDENTIFIER(C) PAR_BEGIN function_call_args(D) PAR_END(Z). {
    auto type = pParser->resolveType(C);
    if (type != nullptr ) {
        auto fnType = pParser->newAstNode<yal::RefType>(type);
        auto fnSrcInfo = pParser->createSourceInfo(C, C);
        fnType->setSourceInfo(fnSrcInfo);
        if (D != nullptr) {
            D->updateSourceInfo();
        }
        A = pParser->newAstNode<yal::ExprStructFnCall>(B, fnType, D);
        auto srcInfo = pParser->createSourceInfo(B->getSourceInfo(), Z);
        A->setSourceInfo(srcInfo);
    }
}

// Binary operators ----------------------------------------------------------

binaryexp(A) ::= expression(B) AND expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::And,
                                                        B, C);
        auto srcInfo = pParser->createSourceInfo(B->getSourceInfo(), C->getSourceInfo());
        A->setSourceInfo(srcInfo);
}
binaryexp(A) ::= expression(B) OR expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Or,
                                                        B, C);
        auto srcInfo = pParser->createSourceInfo(B->getSourceInfo(), C->getSourceInfo());
        A->setSourceInfo(srcInfo);
}
binaryexp(A) ::= expression(B) PLUS expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Plus,
                                                        B, C);
        auto srcInfo = pParser->createSourceInfo(B->getSourceInfo(), C->getSourceInfo());
        A->setSourceInfo(srcInfo);
}
binaryexp(A) ::= expression(B) MINUS expression(C).  {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Minus,
                                                        B, C);
        auto srcInfo = pParser->createSourceInfo(B->getSourceInfo(), C->getSourceInfo());
        A->setSourceInfo(srcInfo);
}
binaryexp(A) ::= expression(B) MULT expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Mult,
                                                        B, C);
        auto srcInfo = pParser->createSourceInfo(B->getSourceInfo(), C->getSourceInfo());
        A->setSourceInfo(srcInfo);
}
binaryexp(A) ::= expression(B) DIV expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Div,
                                                        B, C);
}
binaryexp(A) ::= expression(B) MOD expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Mod,
                                                        B, C);
        auto srcInfo = pParser->createSourceInfo(B->getSourceInfo(), C->getSourceInfo());
        A->setSourceInfo(srcInfo);
}

binaryexp(A) ::= expression(B) EQ expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Eq,
                                                        B, C);
        auto srcInfo = pParser->createSourceInfo(B->getSourceInfo(), C->getSourceInfo());
        A->setSourceInfo(srcInfo);
}

binaryexp(A) ::= expression(B) NE expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Ne,
                                                        B, C);
        auto srcInfo = pParser->createSourceInfo(B->getSourceInfo(), C->getSourceInfo());
        A->setSourceInfo(srcInfo);
}

binaryexp(A) ::= expression(B) LE expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Le,
                                                        B, C);
        auto srcInfo = pParser->createSourceInfo(B->getSourceInfo(), C->getSourceInfo());
        A->setSourceInfo(srcInfo);
}

binaryexp(A) ::= expression(B) LT expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Lt,
                                                        B, C);
        auto srcInfo = pParser->createSourceInfo(B->getSourceInfo(), C->getSourceInfo());
        A->setSourceInfo(srcInfo);
}

binaryexp(A) ::= expression(B) GE expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Ge,
                                                        B, C);
        auto srcInfo = pParser->createSourceInfo(B->getSourceInfo(), C->getSourceInfo());
        A->setSourceInfo(srcInfo);
}

binaryexp(A) ::= expression(B) GT expression(C). {
        A = pParser->newAstNode<yal::ExprBinaryOperator>(yal::BinaryOperatorType::Gt,
                                                        B, C);
        auto srcInfo = pParser->createSourceInfo(B->getSourceInfo(), C->getSourceInfo());
        A->setSourceInfo(srcInfo);
}

// Unary operators -----------------------------------------------------------

unaryexp(A) ::= NOT(Z) expression(B). {
    A = pParser->newAstNode<yal::ExprUnaryOperator>(yal::UnaryOperatorType::Not,
                                               B);
    auto srcInfo = pParser->createSourceInfo(Z, B->getSourceInfo());
    A->setSourceInfo(srcInfo);
}
unaryexp(A) ::= BIT_NOT(Z) expression(B). {
    A = pParser->newAstNode<yal::ExprUnaryOperator>(yal::UnaryOperatorType::BitNot,
                                               B);
    auto srcInfo = pParser->createSourceInfo(Z, B->getSourceInfo());
    A->setSourceInfo(srcInfo);
}
unaryexp(A) ::= MINUS(Z) expression(B). [NEGATE] {
    A = pParser->newAstNode<yal::ExprUnaryOperator>(yal::UnaryOperatorType::Negate,
                                               B);
    auto srcInfo = pParser->createSourceInfo(Z, B->getSourceInfo());
    A->setSourceInfo(srcInfo);
}

// Function call ------------------------------------------------------------

function_call_args(A) ::= function_call_args(B) COMMA expression(C). {
    A = B;
    A->addExpression(C);
}
function_call_args(A)::= expression(B). {
    A = pParser->newAstNode<yal::ExprList>();
    A->addExpression(B);
}
function_call_args(A) ::=. {
    A= nullptr;
}

// Literals ------------------------------------------------------------------

literal(A) ::= INTEGER_LITERAL(B). {
        A = pParser->newIntegerLiteral(B);
        auto srcInfo = pParser->createSourceInfo(B, B);
        A->setSourceInfo(srcInfo);
   }
literal(A) ::= DECIMAL_LITERAL(B). {
        A = pParser->newDecimalLiteral(B);
        auto srcInfo = pParser->createSourceInfo(B, B);
        A->setSourceInfo(srcInfo);
}
literal(A) ::= BOOL_LITERAL(B). {
        A = pParser->newAstNode<yal::ExprBoolLiteral>(B.tokenStr);
        auto srcInfo = pParser->createSourceInfo(B, B);
        A->setSourceInfo(srcInfo);
}


